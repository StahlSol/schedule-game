import random
from dataclasses import dataclass, field
from typing import List, Dict, Optional

# ---------------------------
# Shift constants & configs
# ---------------------------
SHIFT_OFF = "off"
SHIFT_LATE = "late"    # 12:00 - 20:00  (responds in morning; ignores evening except final message)
SHIFT_MID = "mid"      # 10:00 - 18:00  (may respond morning or night; 15% double-book chance)
SHIFT_EARLY = "early"  # 08:00 - 16:00  (responds at night only)

# Probability config (used when a day is a work day)
SHIFT_PROBS = {
    SHIFT_LATE: 0.65,
    SHIFT_MID:  0.25,
    SHIFT_EARLY:0.10,
}

# Base chance a day is a work day when generating schedule
BASE_WORK_CHANCE = 0.85

# Simple human-readable meta for each shift used by UI/logic later
SHIFT_DEFS = {
    SHIFT_LATE:  {"hours": (12, 20), "responds_morning": True,  "responds_evening": False, "double_book_chance": 0.0},
    SHIFT_MID:   {"hours": (10, 18), "responds_morning": True,  "responds_evening": True,  "double_book_chance": 0.15},
    SHIFT_EARLY: {"hours": (8,  16), "responds_morning": False, "responds_evening": True,  "double_book_chance": 0.0},
    SHIFT_OFF:   {"hours": (0,  24), "responds_morning": True,  "responds_evening": True,  "double_book_chance": 0.0},
}


# ---------------------------
# Cheff object (initialization)
# ---------------------------
@dataclass
class Cheff:
    days: int = 11
    seed: Optional[int] = None

    # Mutable state
    mood: int = 100           # 0-100
    memory: int = 100         # 0-100 (freshness for planned events)
    daily_flags: Dict[str, bool] = field(default_factory=lambda: {
        "annoyed": False,
        "hungover": False,
        "called_in": False,
        "event_decided": False,
        "day_decided": False,
        "drinking_stream": False,
        "morning_shift": False,
        "afternoon_shift": False,
        "evening_shift": False,
        "day_off": False,
    })

    # Schedule is a list of day-dicts (index 0..days-1)
    schedule: List[Dict] = field(default_factory=list)

    # bookkeeping for message-overload logic
    messages_without_response: int = 0

    def __post_init__(self):
        if self.seed is not None:
            random.seed(self.seed)
        # generate schedule immediately on creation
        self.generate_schedule(self.days)
        # ensure flags are in the expected base state
        self.reset_daily_flags()

    # ---------------------------
    # Schedule generation
    # ---------------------------
    def generate_schedule(self, days: int):
        """Create `days` worth of schedule entries with shifts or off-days."""
        self.schedule = []
        for i in range(days):
            is_work = random.random() < BASE_WORK_CHANCE
            if is_work:
                shift = self._sample_shift()
            else:
                shift = SHIFT_OFF

            day_entry = {
                "day_index": i,
                "shift": shift,
                "called_in": False,          # set at start-of-day logic if triggered
                "spontaneous_plan": None,    # e.g., "drinking stream", set by dynamic events
                "drinking_stream": False,    # convenience boolean (affects next day hungover)
                "confirmed_event": None,     # event type if player & Cheff agreed
                "confirmed_time": None,      # confirmed time if set
            }
            self.schedule.append(day_entry)

    def _sample_shift(self) -> str:
        """Choose a shift according to SHIFT_PROBS."""
        r = random.random()
        acc = 0.0
        for shift, p in SHIFT_PROBS.items():
            acc += p
            if r < acc:
                return shift
        # fallback (shouldn't reach)
        return SHIFT_EARLY

    # ---------------------------
    # Flag helpers / introspection
    # ---------------------------
    def reset_daily_flags(self):
        """Reset single-day transient flags (called at day start)."""
        for k in list(self.daily_flags.keys()):
            self.daily_flags[k] = False
        # message overload counter persists across the day but reset here:
        self.messages_without_response = 0

    def set_flag(self, name: str, value: bool = True):
        if name not in self.daily_flags:
            raise KeyError(f"Unknown flag: {name}")
        self.daily_flags[name] = value

    def get_shift(self, day_index: int) -> str:
        return self.schedule[day_index]["shift"]

    def describe_schedule(self):
        """Pretty-print the generated schedule (useful during dev)."""
        out = []
        for day in self.schedule:
            idx = day["day_index"] + 1
            shift = day["shift"]
            out.append(f"Day {idx:2}: {shift}")
        return "\n".join(out)


# ---------------------------
# Example usage
# ---------------------------
if __name__ == "__main__":
    cheff = Cheff(days=11, seed=42)
    print("Generated schedule:")
    print(cheff.describe_schedule())
    print("\nSample shift metadata (day 1):", SHIFT_DEFS[cheff.get_shift(0)])


